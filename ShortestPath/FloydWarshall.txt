// "특정 정점 -> 모든 정점": 다익스트라는 가장 적은 비용을 하나씩 선택
// "모든 정점 -> 모든 정점": 플로이드와샬은 "거쳐가는 정점"을 기준으로 수행함!

/**
 * 이중배열 D를 가지고 있음. (정점i -> 정점j 가는 현재까지 계산된 최소 비용)
 * 초기화: 지금 당장 접근 가능한 점점까지의 가중치 (길 없으면 INF)
 *
 * 갱신: 현재 정점을 '거쳐갈 수 있는' 다른 정점들의 가중치 갱신...
 *
 * for문을 3번 돈다 : 모든 정점 방문을 위한 for & 각 정점에 대해 모든 노드의 경로를 계산하기 위한 for 2번
 * └> O(n^3)
 *
 */

for (int i=0; i<n; i++) {
    for (int j=0; j<n; j++)
    D[i][j] = adjMatrix[i][j];   // 이중배열 D 초기화 by 주어진 인접행렬
}

for (int k=0; k<n; k++) {  // 모든 정점을 방문 (각 노드는 중간 노드로서의 의미를 가짐)
    for (int i=0; i<n; i++){  // 각 정점에서 모든 경우의 수 계산
        for (int j=0; j<n; j++) {
            ┌> 즉 현재 k를 중간노드로 삼을 때랑, 안 삼을 때랑 비교하여 더 적은 것을 Distance로 택한다.
            if (D[i][j] > D[i][k] + D[k][j])  // 현재 정점 k를 거쳐 가는 모든 조합에서
                D[i][j] = D[i][k] + D[k][j];
        }
    }
}

// ex: 이중배열 D를 떠올려볼 때, 2번에서 4번 노드로 가는 길은 원래 INF였으나,
//     1번 노드를 중간 노드로 삼는다면 2-> 1-> 4 가 가능해짐
//     SO,, 거리 갱신하게 됨
